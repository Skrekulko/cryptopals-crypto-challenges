## Bleichenbacher's e=3 RSA Attack

#### Crypto-tourism informational placard.

> Remember: you don't simply divide mod N; you multiply by the multiplicative inverse mod N. So you'll need a modinv() function.

RSA with an encrypting exponent of 3 is popular, because it makes the RSA math faster.

With e=3 RSA, encryption is just cubing a number mod the public encryption modulus:

```
 c = m ** 3 % n
```

e=3 is secure as long as we can make assumptions about the message blocks we're encrypting. The worry with low-exponent RSA is that the message blocks we process won't be large enough to wrap the modulus after being cubed. The block 00:02 (imagine sufficient zero-padding) can be "encrypted" in e=3 RSA; it is simply 00:08.

When RSA is used to sign, rather than encrypt, the operations are reversed; the verifier "decrypts" the message by cubing it. This produces a "plaintext" which the verifier checks for validity.

When you use RSA to sign a message, you supply it a block input that contains a message digest. The PKCS1.5 standard formats that block as:

```
00h 01h ffh ffh ... ffh ffh 00h ASN.1 GOOP HASH
```

As intended, the ffh bytes in that block expand to fill the whole block, producing a "right-justified" hash (the last byte of the hash is the last byte of the message).

There was, 7 years ago, a common implementation flaw with RSA verifiers: they'd verify signatures by "decrypting" them (cubing them modulo the public exponent) and then "parsing" them by looking for 00h 01h ... ffh 00h ASN.1 HASH.

There are two ways to approach this problem:
- You can work from Hal Finney's writeup, available on Google, of how Bleichenbacher explained the math "so that you can do it by hand with a pencil".
- You can implement an integer cube root in your language, format the message block you want to forge, leaving sufficient trailing zeros at the end to fill with garbage, then take the cube-root of that block.

Forge a 1024-bit RSA signature for the string "hi mom". Make sure your implementation actually accepts the signature!

## Explanation

The signature scheme *RSASSA-PKCS1-v1_5* defined in [PKCS# Version 2.1](https://www.rfc-editor.org/rfc/rfc3447) is described as follows:

```math
\textrm{$M=00||01||PS||00||T||H$ (ASN.1 format)}
```

where $PS$ is an octet string with $ff$ such that $|M|=|n|$ (and $|PS|\geq 64$), $T$ is an identifier of the algorithm and the hash function as seen on the table below,

<center>

| Hash Function | Length (bit) |              Octet String              |
|      :-:      |      :-:     |                   :-:                  |
|      MD2      |      144     |  3020300c06082a864886f70d020205000410  |
|      MD5      |      144     |  3020300c06082a864886f70d020505000410  |
|     SHA-1     |      120     |     3021300906052b0e03021a05000414     |
|    SHA-256    |      152     | 3031300d060960864801650304020105000420 |
|    SHA-384    |      152     | 3041300d060960864801650304020205000430 |
|    SHA-512    |      152     | 3051300d060960864801650304020305000440 |

</center>

and $H$ is an octet representation of the hash value $H(m)$. Then, a signature $s$ is generated by



```math
s\equiv M^{d}\bmod n
```

for the signer's secret integer $d$ ad his public composite $n$. On input a message $m$, a signature $s$ and the signer's public exponent $e$, a verifier firstly obtains an octet string $M^{'}$ representing an integer $M^{'}\equiv s^{3}\bmod n$ and verifies wheter it satisfies the format

```math
M^{'}=00||01||PS||00||T||H^{'}
```

Then he obtains a value $H^{'}$, an integer representation of the octet string $H^{'}$, and verifies wheter $H^{'}=H(m)$.

In the implementation level, a part of the format check is sometimes inadequate for various rasons. For example, when an octet string

```math
\textrm{$00||01||PS||00||T||H^{'}||$garbage}
```
(a garbage data is followed) is obtained by a verifier as a decoded message, it should be rejected because it is in the illegal format. However, some implementations accept the string because they do not properly check the number of $ff$ (only check $|PS|\geq 64$) and they stop the scan at the end of $H^{'} (namely, they do not notice the existence of the garbage). Such loose implementation is the target of *Bleichenbacher's forgery attack*. For more information on this topic, check out these two great papers ([first](https://ieeexplore.ieee.org/document/4159923) and [second](https://www.jstage.jst.go.jp/article/ipsjjip/16/0/16_0_122/_article)) and this one [article](https://mailarchive.ietf.org/arch/msg/openpgp/5rnE9ZRN1AokBVj3VqblGlP63QE/).






